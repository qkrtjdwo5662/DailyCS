# 자료구조 기본

태그: 자료구조

### Array(Static)

- 데이터를 메모리상에 연속적, 순차적으로 미리 할당된 크기만큼 저장하는 자료구조
- 고정된 크기의 저장공간
- 순차적인 데이터 저장
- 연속적으로 데이터가 저장되어있기에 random access가 가능하다는 장점이 있음
- 고정된 크기를 미리 선언하여 메모리 낭비가 발생할 수 있다.

### Dynamic Array

- 고정된 크기를 갖는 Array와는 다르게 저장공간이 다 차게되면 resize를 통해 size를 유동적으로 조절하여 데이터를 저장하는 자료구조
- 즉, Dynamic Array는 Array기반이지만 고정 크기의 한계를 보완할 수 있는 자료구조
- resizing : 기존 할당된 크기에 데이터가 꽉차게 되면 더 큰 배열을 할당하고 데이터를 옮김
    - 50% 혹은 2배씩 배열의 크기를 늘린다
    - 자바에서는 기본 사이즈가 10이며 resizing 발생 시 기존 크기에서 50%를 늘린다.
    - resizing이 발생하는 경우 O(n)의 시간복잡도가 발생한다.
    - 하지만 resizng은 자주 발생하지 않으므로 마지막 인덱스의 데이터를 삽입하는 연산이 평균적으로 O(1)이라고 함 [amortized O(1)]
- 마지막 인덱스가 아닌 인덱스에서 데이터를 삽입, 삭제 하는 연산은 모든 데이터를 복사해야하는 과정이 발생하기 때문에 O(N)의 시간복잡도가 발생함

### Linked List

- 메모리 상에서는 데이터가 불연속적으로 저장되어있으나 논리적으로 연속성을 구현한 자료구조이다.
- 값과 다음 값의 위치를 저장하는 Node라는 구조체로 이루어져 있음
- 논리적으로 연속성을 구현했기에 인덱스로 데이터에 접근할 수 없어 n번째 데이터에 접근하기 위해서는 O(N)의 시간복잡도가 발생한다.
- 삭제, 삽입 시 연산은 O(1)이 발생하지만 접근 시간을 포함하면 사실상 O(N)의 시간복잡도가 발생한다.

### Array & Linked List

- Array와 비교했을 때 연결리스트의 장점은 데이터가 추가 되는 시점에 메모리를 할당하기 때문에 메모리를 좀 더 효율적으로 사용할 수 있다는 것임
- Array는 컴파일 단계에서 Linked List는 runtime 단계에서 메모리 할당이 일어난다.
- Array는 메모리상에 연속적, Linked List는 메모리 상에 불연속적으로 데이터가 저장된다.
- 따라서 Array는 배열 첫 데이터의 주소값 + Offset으로 이루어져 있어 random access에 장점이 있음
- Linked List는 논리적인 연속성을 갖고 있어 Node 구조체의 NextAddress를 통해 순차 접근만 가능하다.

### Queue

- 큐는 데이터가 논리적으로 연속성이 구현되어 있는 선형 자료구조이다.
- 선입선출의 자료구조로서 FIFO(먼저 들어온 데이터가 먼저 나감)자료구조라고 한다.
- 캐시 구현, 프로세스 관리, 너비우선탐색에 활용된다.
- 데이터를 추가하는 것을 enqueue, 데이터를 삭제(추출)하는 것을 dequeue라고 한다.
- 두 과정 모두 O(1)의 시간복잡도가 발생한다.
- 큐는 Array-Based Queue와 List-Based 큐로 나눌 수 있음
    - Array-Based Queue : 배열 기반으로 이루어진 큐로 enqueue와 dequeue 과정에서 남는 메모리가 발생함. 메모리의 낭비를 줄이기 위해 원형 큐 형식으로 구현한다.
    - List-Based Queue : 연결 리스트 기반으로 이루어진 큐로서 resizing 및 메모리 낭비의 문제가 없다. 데이터를 삽입하는 상황에서 메모리 할당이 이루어져 성능적으로 떨어질 수도 있음

### Stack

- 스택은 데이터가 논리적으로 연속성이 구현되어 있는 선형 자료구조이다.
- 후입선출의 자료구조로서 LIFO(나중에 들어온 데이터가 먼저 나감)자료구조라고 한다.
- 후위 표기법 연산, 괄호 유효성 검사, 웹 브라우저 방문 기록 등에 활용된다.
- 데이터를 추가하는 것을 push, 데이터를 삭제(추출)하는 것을 pop이라고 한다.
- 두 과정 모두 O(1)의 시간복잡도가 발생한다.

### Priority Queue

- 우선순위 큐는 비선형 자료구조이다.
- Heap이라는 완전 이진 트리로 구현한다.
- 일반적인 큐와는 다르게 데이터의 삽입 순서와 관계없이 우선순위가 가장 높거나 낮은 데이터를 먼저 꺼낸다.
    - 우선순위가 높은 데이터부터 꺼내는 힙을 Max Heap
    - 우선순위가 낮은 데이터부터 꺼내는 힙을 Min Heap
- 데이터의 삽입, 삭제 시 O(logN)의 시간복잡도가 발생한다.
- 이는 heap tree의 높이만큼 swap과정이 발생할 수 있기 때문이다.
- 힙은 데이터를 추가할 때 완전히 정렬되는 것이 아닌 꺼낼때 비로소 완전한 정렬이 이루어진다.

### BST

- 이진탐색트리는 비선형 자료구조이다.
- 이진탐색트리는 정렬된 트리로서 정렬을 유지하면서 데이터의 삽입/삭제를 O(logN)만에 할 수 있음
- 어떤 노드를 선택하든 해당 노드의 왼쪽 서브트리에는 작은 값으로 오른쪽 서브트리에는 큰 값으로 이루어져있다.
- 검색, 저장, 삭제 모두 O(logN)이 발생하지만 최악의 상황에서 한쪽으로 치우친 트리인 경우 O(N)이 발생한다.
- 치우친 경우의 한계를 보완하기 위해 자가 균형 이진트리가 있으며 AVL트리와 Red-black트리가 대표적이다.
- Java에서는 TreeSet이 Red-Black 트리로 구현되어있다.

  

### HashTable

- 해시 테이블은 비선형 자료구조이다.
- 해시 테이블은 빠른 탐색을 위한 자료구조로 key-value 쌍의 데이터를 입력받는다.
- 해시 함수에 key값을 입력하여 얻은 해시 값을 위치로 Key-value 데이터 쌍을 저장한다.
- key, value를 저장할 수 있는 공간을 버킷 혹은 슬롯이라고 한다.
- 저장, 삭제, 검색의 시간복잡도는 O(1)이다.
- Direct-address Table(직접 주소화 테이블)
    - key값을 인덱스로 value를 저장하는 방식
    - 하지만 직접 주소화 테이블 방식은 key로 다양한 자료형을 담을 수 없다는 한계가 있음
- 해시 충돌
    - key값의 종류는 무한대에 가깝지만 메모리는 유한하기 때문에 서로 다른 key의 해시 값이 같은 경우가 발생한다. 이를 해시 충돌이라고 함
    - 이를 해결하기 위한 방법으로는 Open Addressing 방법과 Separate Chaining 기법이 있음
- Open Addressing : 비어있는 다른 버킷을 찾아 데이터를 저장하는 방식
    - 선형 조사법 : 충돌이 발생한 해시 값으로부터 일정한 값만큼 건너 뛰어서 비어있는 슬롯을 찾는 방식
    - 이차 조사법 : 선형조사법과 유사하고 제곱수 만큼 건너 뛰어서 비어있는 슬롯을 찾는 방식
    - 선형 조사법, 이차 조사법 모두 특정 영역에 데이터가 집중적으로 몰리는 클러스터링 현상이 발생할 수 있다는 단점이 있음
    - Double Hashing : 2개의 해시함수를 사용하는 방식으로 하나는 최초 해시값을 얻을 때 사용하고, 하나는 해시 충돌이 발생할 때 탐사 이동폭을 얻기 위해 사용함
- Separate Chaining : 충돌이 발생한 버킷의 데이터를 연결 리스트 혹은 BST로 연결하는 방식
    - Linked List로 연결하는 경우 검색의 시간복잡도가 O(N)이 발생한다.
    - 따라서 해시 충돌이 많이 발생하여 Linked List길이가 길어지는 경우 성능 저하 문제를 고려하여 BST를 사용할 수 있음